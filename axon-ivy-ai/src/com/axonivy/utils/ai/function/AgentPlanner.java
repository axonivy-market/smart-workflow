package com.axonivy.utils.ai.function;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.lang3.StringUtils;

import com.axonivy.utils.ai.connector.AbstractAiServiceConnector;
import com.axonivy.utils.ai.core.AiStep;
import com.axonivy.utils.ai.core.tool.IvyTool;
import com.axonivy.utils.ai.dto.ai.FieldExplanation;
import com.axonivy.utils.ai.persistence.converter.BusinessEntityConverter;

import dev.langchain4j.model.chat.request.json.JsonArraySchema;
import dev.langchain4j.model.chat.request.json.JsonObjectSchema;
import dev.langchain4j.model.chat.request.json.JsonSchema;
import dev.langchain4j.model.chat.request.json.JsonSchemaElement;
import dev.langchain4j.model.chat.request.json.JsonStringSchema;
import dev.langchain4j.model.input.PromptTemplate;

public class AgentPlanner extends AiFunction<IvyTool, List<AiStep>> {

  private static final String TEMPLATE = """
      QUERY:
      {{query}}
      -------------------------------
      PROVIDED TOOLS:
      {{tools}}
      -------------------------------
      INSTRUCTION:
      - Each tool is capable of doing some tasks, analyze carefully before making decision
      - Only use the tools above, create a step-by-step plan to handle the query
      - Each step of the plan should have three info:
        + Step No: An incremental number field, start with 1
        + Analysis: explanation why use this tool
        + Tool ID: ID of the selected tool
        + Next: Number next step, -1 if final step. The flow should finish after that
        + Previous: Number of the previous step
      - Tool ID is REQUIRED. Do not create a step without using tool ID from above.
      - Review the plan you created does it good enough? Is there any unnecessary optional steps? Is there any missing steps that are critical to do?
      {{customInstructions}}
      -------------------------------
      OUTPUT FORMAT:
      should be exactly like this:

      {toolId: <tool id 1> , analysis: <your analysis 1> , stepNo: <step Number 1> , previous: <previous step number> , next: <Next step number>},
      {toolId: <tool id 2> , analysis: <your analysis 2> , stepNo: <step Number 2> , previous: <previous step number> , next: <Next step number>},
      """;

  private static final String AGENT_PART_TEMPLATE = """
      Avaiable tools:
      {{tools}}
      """;

  private static final String TOOL_LINE_FORMAT = """
        + ID: %s
          Usage: %s
      """;

  private static final String STEPS = "steps";

  private List<IvyTool> tools;
  private String generatedPlan;

  public static Builder getBuilder() {
    return new Builder();
  }

  @Override
  protected boolean validateInputs() {
    return super.validateInputs() && CollectionUtils.isNotEmpty(tools);
  }

  @Override
  protected Map<String, Object> buildParameters() {
    String toolsPrompt = CollectionUtils.isEmpty(tools) ? StringUtils.EMPTY : buildToolsPrompt();

    Map<String, Object> params = new HashMap<>();
    params.put("tools", toolsPrompt);
    params.put("query", getQuery());
    params.put("customInstructions", formatCustomInstructions());

    return params;
  }

  @Override
  protected JsonSchema generateJsonSchema() {
    JsonSchemaElement itemSchema = JsonStringSchema.builder().description("Step details of the plan").build();

    JsonSchemaElement arraySchema = JsonArraySchema.builder()
        .description("All steps of the plan generated by the providing input").items(itemSchema).build();

    JsonSchemaElement rootSchema = JsonObjectSchema.builder().description("the plan generated by the providing input")
        .addProperty(STEPS, arraySchema).build();

    return JsonSchema.builder().name("Plan").rootElement(rootSchema).build();
  }

  @Override
  protected List<AiStep> parseJsonResponse(String jsonResponse) {
    List<String> stepsStr = parseJsonArray(jsonResponse, STEPS);

    List<AiStep> steps = new ArrayList<>();
    StringBuilder planStrBuilder = new StringBuilder();

    // Map plan content to a list of AiSteps using execution AI model
    DataMapper.Builder dataMapperBuilder = DataMapper.getBuilder().useService(getConnector()).withObject(new AiStep())
        .addFieldExplanations(Arrays.asList(new FieldExplanation("stepNo", "Incremental integer, starts at 1"),
            new FieldExplanation("name", "Name of the step"), new FieldExplanation("analysis", "Analysis of the step"),
            new FieldExplanation("toolId", "Tool ID to execute the step"),
            new FieldExplanation("next", "ID of the next step, -1 if final"),
            new FieldExplanation("previous", "ID of the previous step, 0 if initial"),
            new FieldExplanation("resultName", "Expected result name"),
            new FieldExplanation("resultDescription", "Expected result description")));

    planStrBuilder.append("Plan to execute the agent:").append(System.lineSeparator());
    for (String stepStr : stepsStr) {
      AiStep step = BusinessEntityConverter
          .jsonValueToEntity(dataMapperBuilder.withQuery(stepStr).build().execute().getSafeValue(), AiStep.class);
      steps.add(step);
      planStrBuilder.append(BusinessEntityConverter.entityToJsonValue(step)).append(System.lineSeparator());
    }

    generatedPlan = planStrBuilder.toString().strip();
    return steps;
  }

  @Override
  protected String getTemplate() {
    return TEMPLATE;
  }

  private String buildToolsPrompt() {
    String result = StringUtils.EMPTY;
    for (var tool : tools) {
      String line = String.format(TOOL_LINE_FORMAT, tool.getId(), tool.getUsage());
      result = result.concat(line);
    }

    Map<String, Object> params = new HashMap<>();
    params.put("tools", result);
    return PromptTemplate.from(AGENT_PART_TEMPLATE).apply(params).text();
  }

  // Getters and setters for domain-specific fields
  public List<IvyTool> getTools() {
    return tools;
  }

  public void setTools(List<IvyTool> tools) {
    this.tools = tools;
  }

  public String getGeneratedPlan() {
    return generatedPlan;
  }

  public List<AiStep> getSteps() {
    return getResult();
  }

  // Builder class for AgentPlanner
  public static class Builder extends AiFunction.Builder<IvyTool, List<AiStep>, AgentPlanner> {
    private List<IvyTool> tools;

    @Override
    public Builder useService(AbstractAiServiceConnector connector) {
      return (Builder) super.useService(connector);
    }

    @Override
    public Builder withQuery(String query) {
      return (Builder) super.withQuery(query);
    }

    @Override
    public Builder addCustomInstructions(List<String> instructions) {
      return (Builder) super.addCustomInstructions(instructions);
    }

    @Override
    public Builder addCustomInstruction(String instruction) {
      return (Builder) super.addCustomInstruction(instruction);
    }

    @Override
    public Builder addInputData(List<IvyTool> data) {
      return (Builder) super.addInputData(data);
    }

    public Builder addTool(IvyTool tool) {
      if (this.tools == null) {
        this.tools = new ArrayList<>();
      }
      this.tools.add(tool);
      return this;
    }

    public Builder addTools(List<IvyTool> tools) {
      if (this.tools == null) {
        this.tools = new ArrayList<>();
      }
      this.tools.addAll(tools);
      return this;
    }

    @Override
    public AgentPlanner build() {
      AgentPlanner planner = new AgentPlanner();
      planner.setConnector(connector);
      planner.setQuery(query);
      planner.setCustomInstructions(customInstructions);
      planner.setTools(tools);
      return planner;
    }
  }
}
